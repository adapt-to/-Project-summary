=============
03_软件实现功能详解
=============

本部分将详细介绍，在软件代码的编写工程中所实现的各种功能，并给出实现功能的代码片段

1. 与硬件的通信
==============

该功能是使用python中的第三方库ZeroMQ。

.. note::
    1. ZeroMQ（简称ZMQ）是一个基于消息队列的多线程网络库，其对套接字类型、连接处理、帧、甚至路由的底层细节进行抽象，提供跨越多种传输协议的套接字。
    2. ZMQ是网络通信中新的一层，介于应用层和传输层之间（按照TCP/IP划分），其是一个可伸缩层，可并行运行，分散在分布式系统间。
    3. ZMQ不是单独的服务，而是一个嵌入式库，它封装了网络通信、消息队列、线程调度等功能，向上层提供简洁的API，应用程序通过加载库文件，调用API函数来实现高性能网络通信。

实现的代码片段(注释参见源码64行处)::

    class Slot_serial(object):
        def __init__(self, address, port):
            self.port = port
            self.address = address
            self.context = zmq.Context()
            self.socket = self.context.socket(zmq.REQ)
            self.socket.connect("tcp://%s:%s" % (self.address, self.port))
            self.poller = zmq.Poller()
            self.poller.register(self.socket, zmq.POLLIN)

使用ZMQ能够和轻松的构建一个客户端-服务端架构。

2. 显示框实时反馈软件操作
==============

利用向函数传入信息，通过函数内部的判断并将需要显示的信息于显示框中显示。具体代码片段实现如下(注释参见源码228行处)::

    def con_serial_v(self, message):
        a = self.tabWidget.currentIndex()
        starttime = time.strftime("%H:%M:%S - ", time.localtime(time.time()))
        if a == 0:
            self.textBrowser_BB84_show.append('{0}{1}'.format(starttime, message))
            textcursor = QtGui.QTextCursor(self.textBrowser_BB84_show.textCursor())
            self.textBrowser_BB84_show.moveCursor(textcursor.atStart())
        elif a == 1:
            self.textBrowser_COW_show.append('{0}{1}'.format(starttime, message))
            textcursor = QtGui.QTextCursor(self.textBrowser_COW_show.textCursor())
            self.textBrowser_COW_show.moveCursor(textcursor.atStart())
        self.logger.logger.info(message)
        text = self.serialer.request_serial(message)
        try:
            text = unicode(text, 'gb2312')
            text = text.encode('utf8')
        except:
            pass
        endtime = time.strftime("%H:%M:%S - ", time.localtime(time.time()))
        if a == 0:
            self.textBrowser_BB84_show.append('{0}{1}'.format(endtime, text))
            textcursor = QtGui.QTextCursor(self.textBrowser_BB84_show.textCursor())
            self.textBrowser_BB84_show.moveCursor(textcursor.atStart())
        elif a == 1:
            self.textBrowser_COW_show.append('{0}{1}'.format(endtime, text))
            textcursor = QtGui.QTextCursor(self.textBrowser_COW_show.textCursor())
            self.textBrowser_COW_show.moveCursor(textcursor.atStart())
        self.logger.logger.info(text)
        return text

3. 诱骗态占比随机调节
==============

实现诱骗态占比的随机调节是根据用户输入的数据进行不同的处理，相应处理方式是:

.. note::
   1. 输入的为0~100内的数值，那么会根据输入的数据对随机数范围进行标定
   2. 输入的为小于0或大于100的数值，那么显示框会反馈让用户重新输入数据
   3. 输入的是非数字字符，那么显示框会反馈让用户重新输入
   4. 不输入任何数值，那么会默认诱骗态占比为30%

实现的代码片段如下(注释参见源码260行)::

    def con_serial_zidingyi(self, message,flage=0):
        global ADDRESS
        a = self.tabWidget.currentIndex()
        if flage==0:
            starttime = time.strftime("%H:%M:%S - ", time.localtime(time.time()))
            if a == 0:
                self.textBrowser_zidingyi.append('{0}{1}'.format(starttime, message))
                self.textBrowser_zidingyi.moveCursor(textcursor.atStart())
            elif a == 1:
                self.textBrowser_zidingyi_cow.append('{0}{1}'.format(starttime, message))
                textcursor = QtGui.QTextCursor(self.textBrowser_zidingyi_cow.textCursor())
                self.textBrowser_zidingyi_cow.moveCursor(textcursor.atStart())
            text = self.serialer.request_serial(message)
            try:
                text = unicode(text, 'gb2312')
                text = text.encode('utf8')
            except:
                pass
            endtime = time.strftime("%H:%M:%S - ", time.localtime(time.time()))
            if a == 0:
                self.textBrowser_zidingyi.append('{0}{1}'.format(endtime, text))
                textcursor = QtGui.QTextCursor(self.textBrowser_zidingyi.textCursor())
                self.textBrowser_zidingyi.moveCursor(textcursor.atStart())
            elif a == 1:
                self.textBrowser_zidingyi_cow.append('{0}{1}'.format(endtime, text))
                textcursor = QtGui.QTextCursor(self.textBrowser_zidingyi_cow.textCursor())
                self.textBrowser_zidingyi_cow.moveCursor(textcursor.atStart())
        elif flage==1:
            path = '/'.join(ADDRESS.split('/')[0:-1])

            if not os.path.exists(path):
                os.makedirs(path)

            if a == 0:
                if '.txt' in ADDRESS.split('/')[-1]:
                    ADDRESS = path + '/' + ADDRESS.split('/')[-1]
                else:
                    time_end = time.strftime("-%Y-%m-%d-%H:%M:%S", time.localtime(time.time()))
                    filename = 'BB84' + time_end + '.txt'
                    ADDRESS = path + '/' + filename
                with open(ADDRESS, 'w') as f:
                    pass
                self.textBrowser_BB84_show.append(u'{0}{1}\n目录文件设置成功：{2} '.format(time.strftime("%H:%M:%S - ", time.localtime(time.time())), message,ADDRESS))
                textcursor = QtGui.QTextCursor(self.textBrowser_BB84_show.textCursor())
                self.textBrowser_BB84_show.moveCursor(textcursor.atStart())
            elif a == 1:
                if '.txt' in ADDRESS.split('/')[-1]:
                    ADDRESS = path + '/' + ADDRESS.split('/')[-1]
                else:
                    time_end = time.strftime("-%Y-%m-%d-%H:%M:%S", time.localtime(time.time()))
                    filename = 'COW' + time_end + '.txt'
                    ADDRESS = path + '/' + filename
                with open(ADDRESS, 'w') as f:
                    pass
                self.textBrowser_COW_show.append(u'{0}{1}\n目录文件设置成功：{2} '.format(time.strftime("%H:%M:%S - ", time.localtime(time.time())), message,ADDRESS))
                textcursor = QtGui.QTextCursor(self.textBrowser_COW_show.textCursor())
                self.textBrowser_COW_show.moveCursor(textcursor.atStart())
            return 1
        return text

4. 参数查询和设置
==============

在这部分，是利用pyqt中的槽和信号的绑定来实现的，通过点击按钮就可以执行装饰器装饰的函数，显示或者设置相应的参数。
通过这样的方式可以很轻松的复用多个按钮。实现的代码片段如下(注释参见源码329行处)::

    @QtCore.pyqtSignature("")
    def on_pushButton_range_clicked(self):
        range = unicode(self.lineEdit_qrng_range.text(), 'utf8', 'ignore').encode('gb2312')
        if not range == '':
            try:
                answer = self.con_serial(float(range))
            except ValueError:
                a = u'诱骗态占比设置：' + range
                anster = self.con_serial(a)
        else:
            answer = self.con_serial(30)

这里通过调节诱骗态占比的按钮举例，通过装饰器 ``@QtCore.pyqtSignature("")`` 可以对下面的函数进行装饰，装饰后的函数就具有了槽和信号的功能(注意：被装饰的函数的函数名是具有固定的写法)。
这样，点击相应的按钮后就能够执行对应的函数，在不同的函数中执行不同的操作就可以实现不同的功能。


5. 实现随机数的实时加载显示
==============

实现这个功能所需要的操作是把执行UI界面的程序逻辑和执行随机数实时加载的程序逻辑进行分开处理，所以这里用到了多线程的形式。
使用多线程能够避免两个逻辑在同时执行时发生冲突，也可以实时显示信息，具体的代码片段如下(注释参见源码678行处)::
    
    @QtCore.pyqtSignature("")
    def on_pushButton_BB84_clicked(self):
        self.bb84_1 = threading.Thread(target=self.BB84_clicked, name='')
        self.bb84_1.setDaemon(True)
        self.bb84_1.start()

在上述代码中，首先使用 ``threading.Thread()`` 函数创建一个子线程，此时子线程还未执行。当执行 ``self.bb84_1.start()`` 后，该子线程得到命令，开始执行。
直到主线程退出或者主动结束子线程前，它会一直运行。这也正好满足我们需要实时下发随机数的要求。

6. 预期目标
==============

7. 预期目标
==============

8. 预期目标
==============

9. 预期目标
==============

10. 预期目标
==============

11. 预期目标
==============